contract loan {
event loanCreated(string outMsg,uint loanId);
event PrintMsg(string outMsg);
event contributeMsg(uint amount);
event sendEvent(bool val);
event loanInfoEvnt(string outMsg,uint fundingGoal,uint tenor,uint numfunders,uint amount);
    struct Funder {
        address addr;
        uint amount;
    }
   
    struct Loan {
        address beneficiary;
        uint fundingGoal;
        uint numFunders;
        uint amount;
        uint deadline;
        uint grace_period;
        uint tenor;
        uint interest_rate;
        mapping (uint => Funder) funders;
    }
   uint[] loanIdArr;
    uint numLoans;
     mapping (uint => Loan) loans;
    
    function newLoan(address beneficiary, uint goal, uint deadline, uint grace_period, uint tenor, uint interest_rate) returns (uint LoanID) {
        LoanID = numLoans++; 
        Loan l = loans[LoanID]; 
        l.beneficiary = beneficiary;
        l.fundingGoal = goal;
        l.deadline = block.number + deadline;
        l.grace_period = l.deadline + grace_period;
        l.tenor = l.grace_period + tenor;
        loanIdArr.push(LoanID);
        loanCreated("loan created",LoanID);
    }
     function contribute(uint LoanID,address contributor,uint amount) {
     PrintMsg("contributing");
        Loan l = loans[LoanID];
        Funder f = l.funders[l.numFunders++]; 
        f.addr = contributor;
        f.amount = amount;
        l.amount += f.amount;
        PrintMsg("contributed");
        contributeMsg(l.amount);
    }
    function checkGoalReached(uint LoanID) returns (bool reached) {
     PrintMsg("checking goal reached");
    
        Loan l = loans[LoanID];
        if (l.amount >= l.fundingGoal){
            PrintMsg(" goal reached");
            uint i = 0;
            uint f = l.numFunders;
            bool tst=l.beneficiary.send(l.amount); 
            sendEvent(tst);
            l.amount = 0;
            l.beneficiary = 0;
            l.fundingGoal = 0;
            l.deadline = 0;
            l.numFunders = 0;
            while (i <= f){
                l.funders[i].addr = 0;
                l.funders[i].amount = 0;
                i++;
            }
        return true;
        }
        if (l.deadline <= block.number){
        PrintMsg("second loop");
            uint j = 0;
            uint n = l.numFunders;
            l.beneficiary = 0;
            l.fundingGoal = 0;
            l.numFunders = 0;
            l.deadline = 0;
            l.amount = 0;
            while (j <= n){
                l.funders[j].addr.send(l.funders[j].amount);
                l.funders[j].addr = 0;
                l.funders[j].amount = 0;
                j++;
            }
            return true;
        }
        return false;
    }
    
     function repayLoan(uint LoanID) {
        Loan l = loans[LoanID];
        Funder f = l.funders[l.numFunders++]; 
        f.addr = msg.sender;
        f.amount = msg.value;
        l.amount += f.amount;
    }
    
    function loanInfo(uint loanId) returns (uint ,uint,uint,address)
    {
     PrintMsg("getting loanInfo");
    
     Loan l = loans[loanId];
     PrintMsg("done loanInfo");
      address beneficiary=l.beneficiary;
     loanInfoEvnt("before initial",l.fundingGoal,l.tenor,l.numFunders,l.amount);
     uint loanTargetAmount=l.fundingGoal;
     uint tenor=l.tenor;
     uint i = 0;
     uint f = l.numFunders;
     address[]  funderAddr;
     uint[]  fundingAmount;
     while (i < f){
      funderAddr[i]= l.funders[i].addr;
       fundingAmount[i]=l.funders[i].amount;
     i++;
            }
            uint loanAmount=l.amount;
    
    return(loanTargetAmount,tenor,loanAmount,beneficiary);
    }
    function getAllLoans() returns(uint[])
    {
        return loanIdArr;
    }
}

